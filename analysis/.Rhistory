3+1
a=4
b=5
a+b
install.packages(c("JGR","Deducer","DeducerExtras"))
Sys.setenv(NOAWT=1)
library(JGR)
Sys.unsetenv("NOAWT")
JGR()
install.packages("Rcmdr", dependencies = TRUE)
library(Rcmdr)
lib.loc
installed.packages(lib.loc = NULL, priority = NULL,
noCache = FALSE, fields = NULL,
subarch = .Platform$r_arch)
installed.packages(lib.loc = NULL, priority = NULL,
noCache = FALSE, fields = NULL,
subarch = .Platform$r_arch)
remove.packages(deducer, .libPaths)
Total.damage.weevils <- read.csv("~/Desktop/Total damage weevils.csv")
View(Total.damage.weevils)
install.packages("ggplot2")
install.packages("pscl")
install.packages("boot")
zinb?
zinb
zinb <- read.csv(Total.damage.weevils.csv)
zinb <- read.csv(Total damage weevils.csv)
ggplot(zinb, aes(count)) + geom_histogram() + scale_x_log10()
pi*3
signif(1, digits=6)
seq(1,100)
x<-seq(1,100)
x
sum(x)
sum(x); y
x
log10x<-log10(x)
log10x
factorial(x)
objects()
rank(x)
sem<-function(var) {
nvar<-length(var)
na_remove=which(is.na(var))
nvar=nvar-length(na_remove)
return (sd(var, na.rm=TRUE)/ sqrt(nvar) )
}
sem(x)
rnorm<-rnorm(100, mean=10, sd=2)
sem(rnorm)
ci_95<-function (var) {
nvar=length(var)
na_remove=which(is.na(var))
nvar=nvar-length(na_remove)
ci_coef=qt(0.975,df=nvar-1)
return(mean(var, na.rm=TRUE) + c(-ci_coef, ci_coef) * sem(var))
}
x[-1]
z<-x>5
norm50<-rnorm(50, mean=10, sd=2)
norm50x<-runif(50, min=5, max=15)
hist(norm50)
hist(norm50x)
par(mfrow=c(1,2))
(?hist)
hist(norm50, col=254)
shapiro.test(norm50)
plot(norm50, norm50x)
plot(norm50, norm50x) [abline]
abline(plot)
plot(uniform, col=254)
andy<-read.table("Total damage weevils.csv", header=TRUE, sep=",")
class(andy)
names(andy)
length(which(is.na(andy)))
hist(andy$Total_Damage, col=365)
6*3
Damage_Total<-andy
(?glm)
boxplot(norm50, norm50x)
mosaicplot(norm50)
abline(norm50)
sunflowerplot(norm50x)
View(Damage_Total)
hist(Damage_Total$Total_Damage)
summary(Damage_Total$Total_Damage)
data=Damage_Total
mod<-lm(Total_Damage ~ Population, data=Damage_Total)
summary(mod)
anova(mod)
plot(Damage_Total$Total_Damage ~ Damage_Total$Population)
Total_Damage<-Damage_Total$Total_Damage
plot(Total_Damage ~ Damage_Total$Population)
shapiro.test(residuals(mod))
library(MASS)
boxcox(mod, plotit=T)
savehistory("~/Desktop/Untitled.Rhistory")
source('~/Dropbox/Intro to R/Practice.R')
source('~/Dropbox/Intro to R/Practice.R')
source('~/Dropbox/Intro to R/Practice.R')
source('~/Dropbox/Intro to R/Practice.R')
source('~/Dropbox/Intro to R/Practice.R')
dataframenorm100norm1000<-data.frame(norm100, norm1000)
## ANALYSING CHANGE IN COVER AT QHI ##
## Team Shrub R Tutorial            ##
## Written by Anne Bjorkman, iDiv   ##
## 21 November 2014                 ##
#"file.choose()" allows you to navigate to the file you want to import, otherwise you can enter the path name here instead
coverQHI<-read.csv(file="scripts/practice_scripts/team_shrub_practice_R_sessions/ITEXCover_QHI.csv",stringsAsFactors = FALSE,strip.white = TRUE,na.strings = c("NA",""))
#strip.white removes any extra spaces after words, na.strings designates which cells should be identified as missing (in this case, any cells that are blank or those with "NA" in them)
#check the import and see what the column names are and what the data structure is
head(coverQHI) #you can also look at the last five lines of your data using tail()
str(coverQHI) #make sure things that should be numbers are numbers (or integers)
#to see the unique values of any column, use
unique(coverQHI$Name) #all the species in the QHI dataset, note some of the "morphospecies" (those with XXX) are still included here
##=== SUBSET ===##
#SUBSET - for some analyses, we might want to get rid of these morphospecies
#we could do this manually, or tell R to exclue any species names that start with "XX"
#I like to do this by making a new column indicating whether a species is a "morphospecies" or not - that way I can keep only one dataset and then decide for each analyses whether I want to include these morphospecies or not
coverQHI$Morphosp<-0 #to start with, ALL species have the value of "0"
coverQHI$Morphosp[substr(coverQHI$Name,1,2)=="XX"]<-1 #then, for those names that start with "XX", I change this value to 1
#if you're ever not sure what an R term does, you can always type
?substr
#To create a new dataset WITHOUT these morphospecies:
cover.nomorpho<-coverQHI[coverQHI$Morphosp != 1,] #[all rows of the dataframe coverQHI EXCEPT those where the value of the "Morphosp" column is 1, all columns]
##=== BASIC DATA EXPLORATION ===##
#In which years was cover data recorded?
unique(coverQHI$YEAR)
#How many species were recorded in total, across all years?
length(unique(coverQHI$Name))
#How many species were recorded in each year?
aggregate(coverQHI$Name,by=list(coverQHI$YEAR),FUN=function(x) length(unique(x)))
#Aggregate is a very useful function - you can add many different functions after the "FUN=" part, including mean, max, min, or write your own function (as we did here)
#Right now we are counting the number of species INCLUDING morphospecies - what if we want to EXCLUDE morphospecies?
#Of course we can simply use the data subset "cover.nomorpho" we created above:
aggregate(cover.nomorpho$Name,by=list(cover.nomorpho$YEAR),FUN=function(x) length(unique(x)))
#OR we could use the original dataset and ask the aggregate function to exclude values where the column "Morphosp" is 1
aggregate(coverQHI$Name[coverQHI$Morphosp != 1],by=list(coverQHI$YEAR[coverQHI$Morphosp != 1]),FUN=function(x) length(unique(x)))
#these two methods should give you the same answer
##=== ANALYSES ===##
#We want to know about the change in cover over time of the most abundant species. First, we'll figure out which species is the most abundant (on average across all plots and years):
aggregate(coverQHI$COVER[coverQHI$Morphosp != 1],by=list(coverQHI$Name[coverQHI$Morphosp != 1]),FUN=mean,na.rm=TRUE)
#because it's a short list, it's easy enough to scan visually and see that Eriophorum vaginatum is the most abundant species - but we could also save the output of this call as a data frame and then ask R to tell us what the max is, for example:
mean.abund<-as.data.frame(aggregate(coverQHI$COVER[coverQHI$Morphosp != 1],by=list(coverQHI$Name[coverQHI$Morphosp != 1]),FUN=mean,na.rm=TRUE))
head(mean.abund) #note that the column names have changed!
colnames(mean.abund)<-c("Name","MeanCover") #change the column names to something that makes sense
mean.abund$Name[mean.abund$MeanCover==max(mean.abund$MeanCover,na.rm=TRUE)] #extract the value in the column "Name" and the row where the value of "COVER" is equal to the maximum value in the column "COVER"
#For simplicity, we'll make a subset of just the Eriophorum vaginatum data. This is another way to subset data that works for very simple subsets only.
erivag<-subset(coverQHI,Name=="Eriophorum vaginatum")
head(erivag)
##=== LINEAR MODEL ===##
#Because we are repeately measuring the same plots over time, we should use a model that accounts for this temporal autocorrelation. For now, however, we'll just do a simple linear model for this species.
#linear model
lm.1<-lm(erivag$COVER~erivag$YEAR)
summary(lm.1) #model summary (note the p-value of 0.0568 for the "YEAR" term)
#always check the fitted vs. residuals and other model assumptions
plot(lm.1)
##=== GRAPH ===##
#an easy graph with base R
plot(erivag$YEAR,erivag$COVER) #the raw cover data
abline(lm(erivag$COVER~erivag$YEAR)) #this is the change in cover over time predicted by the model
#OR, there is a great package called "ggplot2" that allows you to do a lot of fancy things with your graphs
library(ggplot2)
#there are two main ways to do graphs in ggplot2
#for very simple graphs, use qplot:
qplot(YEAR,COVER,data=erivag,geom=c("point","smooth")) #this is a loess-smoothed curve
qplot(YEAR,COVER,data=erivag,geom=c("point","smooth"),method="lm") #this is a predicted line (+/- SE) according to a linear model, like we did above - there are many options for the "method" argument here - you can write your own equation
#I really dislike the grey background on these plots, so I always use the "theme_bw()" call to remove this
qplot(YEAR,COVER,data=erivag,geom=c("point","smooth"),method="lm")+theme_bw()
#for the more complex - but also more versatile - method, use ggplot:
#this allows you to plot two different datasets or parts of a dataset on the same graph
ggplot(erivag)+
geom_point(aes(x=YEAR,y=COVER))+
geom_smooth(aes(x=YEAR,y=COVER),method="lm")+
theme_bw()
#for example, perhaps we want a line PER PLOT as well as the overall smoothed (predicted) line
ggplot(erivag)+
geom_point(aes(x=YEAR,y=COVER))+
geom_line(aes(x=YEAR,y=COVER,group=PLOT))+ #add a line per plot
geom_smooth(aes(x=YEAR,y=COVER),method="lm")+
theme_bw()
#or if we actually want to know which plot each line corresponds to:
ggplot(erivag)+
geom_point(aes(x=YEAR,y=COVER))+
geom_line(aes(x=YEAR,y=COVER,group=PLOT,colour=PLOT))+ #colour the lines by plot
geom_smooth(aes(x=YEAR,y=COVER),method="lm")+
theme_bw()
#you can do lots of fancy things the change the axes, the colours, the legend, etc.
#there is a lot of very useful info on the ggplot website, http://docs.ggplot2.org/current/
#and some useful into material on the "Cookbook for R" website: http://www.cookbook-r.com/Graphs/
#I like to chose my own colors for graphs using HEX codes, this is a useful website for finding HEX color codes and various shades of those colors: http://www.hexcolortool.com
#here's the same graph as above, but with lots of specifications:
ggplot(erivag)+
geom_point(aes(x=YEAR,y=COVER),size=2.5)+
geom_line(aes(x=YEAR,y=COVER,group=PLOT,colour=PLOT),size=1)+
geom_smooth(aes(x=YEAR,y=COVER),method="lm",colour="black",linetype="dashed")+
theme_bw()+
scale_colour_manual(values=c("#ad0000","#db9200","#36b300","#00afd6","#0024c7","#7700c7"),name="Plot")+ #HEX colour codes go here, and you can also change the legend title using "name="
ylab("Percent Cover\n ")+xlab(" \nYear of Measurement")+theme(legend.title=element_text(size=22,face="plain"),legend.text=element_text(size=20),legend.key = element_blank(),axis.text.x=element_text(size=20,angle=45,vjust=0,hjust=0),axis.text.y=element_text(hjust=0,size=22),axis.title.x=element_text(size=24,face="plain"),axis.title.y=element_text(angle=90,size=24,face="plain"),axis.ticks = element_blank(), panel.grid.major.x=element_blank(),panel.grid.minor.x=element_blank(),panel.grid.minor.y=element_blank(),panel.grid.major.y=element_blank())+scale_x_continuous(breaks=c(1999,2004,2009))+guides(colour = guide_legend(override.aes = list(size = 3)))
#you can remove each specification and see how the graph changes to get a feeling for what each part does
#a few notes:
#it's a bit tricky to learn what goes inside the aes() call and what goes outside it, as in:
#geom_line(aes(x=YEAR,y=COVER,group=PLOT,colour=PLOT),size=1)
#here, colour goes inside because we want the colour to vary by PLOT, whereas size goes outside because we want all lines (plots) to be the same size
#scale_colour_manual() is used for manually specifiying colors of points, lines, etc. - you can use HEX codes or words (e.g., "black", "red", or "blue"). If you want to manually specify a colour that is a FILL instead of a LINE or POINT (for example the "fill" of the ribbon), then use scale_fill_manual() instead, and use fill= instead of colour= in your geom argument - see example of this below
#scale_x_continous allows you to choose where the breaks on the x axis will go (can do the same on the y axis with scale_y_continous)
#guides(colour=guide_legend(override.aes=list())) is a very convoluted way of overriding the legend so that you can change the legend without changing the graph itself. Otherwise if the lines on the graph are size 2 (for example) then the lines in the legend will also be size 2, which might be smaller than desired.
#the graph gets plotted in the order you write the script, so if you want the points to be over top of the lines (instead of the way it is now, with lines over the points) then simply reverse the order of these two lines in the script
##=== ANALYSIS -- MULTIPLE SPECIES ===##
#Now we'll get a bit more advanced and compare cover change for three different species - E. vaginatum, Dryas integrifolia and Salix pulchra, because they are the three most abundant species:
mean.abund[order(mean.abund$MeanCover, decreasing=TRUE),]
top3<-subset(coverQHI,Name %in% c("Eriophorum vaginatum","Dryas integrifolia","Salix pulchra"))
head(top3)
#Note that one of these species (Dryas) occurs in two different subsites - we will ignore this in the model for now but will have to alter our graphing code a little bit to deal with it (see below)
## A MIXED MODEL (TO ACCOUNT FOR REPEATED PLOTS OVER TIME) ##
library(lme4)
#Convert "Name" to a factor for analysis
top3<-within(top3,Namef<-as.factor(Name))
top3<-within(top3,PLOTf<-as.factor(PLOT))
#mixed model with a random effect of "plot"
mixed.m1<-lmer(COVER~I(YEAR-1999)*Namef+(I(YEAR-1999)|PLOTf),data=top3) #The "I" term around YEAR simply means "as is" - we start year at 0 because it reduces problems with correlation between the slope and intercept.
plot(mixed.m1) #fitted vs. residuals
#check for significance of the interaction term
mixed.m2<-lmer(COVER~I(YEAR-1999)+Namef+(I(YEAR-1999)|PLOTf),data=top3)
anova(mixed.m1,mixed.m2) #p=0.87, which means these three species do not do different things over time (i.e., the same slope can be modeled for each species)
mixed.m3<-lmer(COVER~I(YEAR-1999)+(I(YEAR-1999)|PLOTf),data=top3)
anova(mixed.m2,mixed.m3) #p=0.0005, the species have significantly different intercepts
## FIGURE - Incorporating raw data and model predictions
#It's a bit more complicated to graph mixed models, but it can be very useful. This code creates a new "empty" dataset and then fills it with the predicted values from the model we just created. We will use the full model (mixed.m1) for visualization purposes, even though the interaction wasn't significant.
#It is very important that these terms be in the same order as the data that went into the model. Usually it is alphabetical. You can check this:
levels(top3$Namef) #note that "levels" only works with factors
pred.mixed<-expand.grid(YEAR=c(1999,2004,2009),Namef=c("Dryas integrifolia","Eriophorum vaginatum","Salix pulchra"),Year2Name=1,COVER=0) #the Year2Name column of 1's is necessary because of the interaction term
mm <- model.matrix(terms(mixed.m1),pred.mixed)
pred.mixed$COVER <- mm %*% fixef(mixed.m1)
pred.mixed #these are the predicted values of "COVER" for each species in each year, based on the model "mixed.m1"
#now estimate confidence intervals to these estimates
pvar.m1<-diag(mm %*% tcrossprod(vcov(mixed.m1),mm))
#add the confidence interval estimates into the same dataframe as the predicted cover values
pred.mixed<-data.frame(pred.mixed,plo=pred.mixed$COVER-1.96*sqrt(pvar.m1),phi=pred.mixed$COVER+1.96*sqrt(pvar.m1))
pred.mixed #now we have predicted values of cover PER SPECIES, PER YEAR as well as lower and upper CI's for each point
#Graph
#It is often (but not always) nice to include both the raw data and the predicted model output on the same graph. ggplot2 allows us to do this
ggplot()+
layer(data=top3, #this is the raw data
geom='point',mapping=aes(x=YEAR,y=COVER,colour=Name),alpha=1,size=2.5)+scale_colour_manual(values=c("blue","red3","darkgreen"),name="Species",breaks=c("Dryas integrifolia","Eriophorum vaginatum","Salix pulchra"),labels=c("Dryas","Eriophorum","Salix"))+
layer(data=top3,
geom="line",mapping=aes(x=YEAR,y=COVER,colour=Name,group=Namef:PLOTf:factor(SUBSITE)),alpha=0.7,size=0.75)+ #now we need a unique line per species, per plot, per subsite since Dryas occurs in two subsites - take one of these out and see what happens!
layer(data=pred.mixed, #these are the predicted values from the model
geom='ribbon',mapping=aes(
x=YEAR,ymin=COVER,ymax=phi,fill=Namef),alpha=0.5)+scale_fill_manual(values=c("blue","red3","darkgreen"),name="Species",breaks=c("Dryas integrifolia","Eriophorum vaginatum","Salix pulchra"),labels=c("Dryas","Eriophorum","Salix"))+
theme_bw()+ylab("Percent Cover\n")+xlab(" \nYear of Measurement")+
theme(legend.title=element_text(size=22,face="plain"),legend.text=element_text(size=20),legend.key = element_blank(),axis.text.x=element_text(size=20),axis.text.y=element_text(hjust=0,size=22),axis.title.x=element_text(size=24,face="plain"),axis.title.y=element_text(angle=90,size=24,face="plain",vjust=0.5),axis.ticks = element_blank(), panel.grid.major.x=element_blank(),panel.grid.minor.x=element_blank(),panel.grid.minor.y=element_blank(),panel.grid.major.y=element_blank())+scale_x_continuous(breaks=c(1999,2004,2009))
#note that in order to have only one legend (instead of one for the points, one for the lines, and one for the ribbons) you have to make sure they are all named the same thing (inside the scale_colour/scale_fill_manual argument, where name="")
View(pred.mixed)
View(pred.mixed)
data=pred.mixed
plot(Namef~Year2Name)
plot(pred.mixed$Namef~pred.mixed$Year2Name)
png(file="scripts/trait_map.png", width=1000, height=1000)
png(file="/users/johngodlee/Desktop", width=1000, height=1000)
pi*3
signif(1, digits=6)
seq(1,100)
x<-seq(1,100)
x
sum(x)
sum(x); y
x
log10x<-log10(x)
log10x
factorial(x)
objects()
rank(x)
sem<-function(var) {
nvar<-length(var)
na_remove=which(is.na(var))
nvar=nvar-length(na_remove)
return (sd(var, na.rm=TRUE)/ sqrt(nvar) )
}
sem(x)
rnorm<-rnorm(100, mean=10, sd=2)
sem(rnorm)
ci_95<-function (var) {
nvar=length(var)
na_remove=which(is.na(var))
nvar=nvar-length(na_remove)
ci_coef=qt(0.975,df=nvar-1)
return(mean(var, na.rm=TRUE) + c(-ci_coef, ci_coef) * sem(var))
}
x[-1]
z<-x>5
norm50<-rnorm(50, mean=10, sd=2)
norm50x<-runif(50, min=5, max=15)
hist(norm50)
hist(norm50x)
par(mfrow=c(1,2))
(?hist)
hist(norm50, col=254)
shapiro.test(norm50)
plot(norm50, norm50x)
plot(norm50, norm50x) [abline]
abline(plot)
plot(uniform, col=254)
andy<-read.table("Total damage weevils.csv", header=TRUE, sep=",")
class(andy)
names(andy)
length(which(is.na(andy)))
hist(andy$Total_Damage, col=365)
6*3
Damage_Total<-andy
(?glm)
boxplot(norm50, norm50xmosaicplot(norm50)
abline(norm50)
sunflowerplot(norm50x)
View(Damage_Total)
hist(Damage_Total$Total_Damage)
summary(Damage_Total$Total_Damage)
data=Damage_Total
mod<-lm(Total_Damage ~ Population, data=Damage_Total)
summary(mod)
anova(mod)
plot(Damage_Total$Total_Damage ~ Damage_Total$Population)
Total_Damage<-Damage_Total$Total_Damage
plot(Total_Damage ~ Damage_Total$Population)
shapiro.test(residuals(mod))
library(MASS)
boxcox(mod, plotit=T)
tbl = table(norm50, norm50x)
tbl
chisq.test(tbl)
plot(norm50 ~ norm50x)
boxplot(Damage_Total$Total_Damage ~ Damage_Total$Population)
summary(norm50)
c?
?c
c(25,32,1)
c
m(1,2,3,4)
tbl
mod
anova
install.packages('vegan')
install.packages('raster')
install.packages('ggplot2')
library(ggplot2)
qqplotsetwd("~/Dropbox/Weevils/Analysis")
library(ggplot2)
setwd("~/Dropbox/Weevils/Analysis")
read.csv(file="damage.csv")
damage<-read.csv(file="damage.csv")
head(damage)
tail(damage)
damage$block<-as.factor(damage$block)
#Plots
plot(total_damage~population, data=damage)
plot(prev_damage~population, data=damage)
plot(curr_damage~population, data=damage)
#Basic ANOVA
pop_total_lm<-lm(total_damage~population, data=damage)
summary.aov(pop_total_lm)
#ANOVA with block as random
pop_total_wblockr_lmer<-lmer(total_damage~population + (1|block), data=damage)
summary
#Spatial analysis
damage_bl1<-damage[which(damage$block==1),]
damage_bl2<-damage[which(damage$block==2),]
damage_bl3<-damage[which(damage$block==3),]
damage_bl4<-damage[which(damage$block==4),]
rbPal <- colorRampPalette(c('red','blue'))
damage_bl1$col <- rbPal(10)[as.numeric(cut(damage_bl1$total_damage,breaks = 10))]
plot(damage_bl1$x_coord,damage_bl1$y_coord,pch=15,col = damage_bl1$col, cex=2)
qplot(x_coord,y_coord, data=damage_bl1, colour=total_damage) + scale_colour_gradient(low="red", high="blue")
qplot(x_coord,y_coord, data=damage_bl2, colour=total_damage) + scale_colour_gradient(low="red", high="blue")
qplot(x_coord,y_coord, data=damage_bl3, colour=total_damage) + scale_colour_gradient(low="red", high="blue")
qplot(x_coord,y_coord, data=damage_bl4, colour=total_damage) + scale_colour_gradient(low="red", high="blue")
symbols(damage_bl1$x_coord, damage_bl1$y_coord, circles=damage_bl1$total_damage)
symbols(damage_bl1$x_coord, damage_bl1$y_coord, squares=damage_bl1$total_damage)
?symbols
symbols(damage_bl1$x_coord, damage_bl1$y_coord, thermometers=damage_bl1$total_damage)
symbols(damage_bl1$x_coord, damage_bl1$y_coord, circles=damage_bl1$total_damage)
symbols(x_coord, y_coord, circles=total_damage, data=damage_bl2)
symbols(damage_bl2$x_coord, damage_bl2$y_coord, circles=damage_bl2$total_damage)
symbols(damage_bl3$x_coord, damage_bl3$y_coord, circles=damage_bl3$total_damage)
symbols(damage_bl4$x_coord, damage_bl4$y_coord, circles=damage_bl4$total_damage)
damage_bl1<-damage[which(damage$block==1),]
damage_bl2<-damage[which(damage$block==2),]
damage_bl3<-damage[which(damage$block==3),]
damage_bl4<-damage[which(damage$block==4),]
rbPal <- colorRampPalette(c('red','blue'))
damage_bl1$col <- rbPal(10)[as.numeric(cut(damage_bl1$total_damage,breaks = 10))]
plot(damage_bl1$x_coord,damage_bl1$y_coord,pch=15,col = damage_bl1$col, cex=2)
qplot(x_coord,y_coord, data=damage_bl1, colour=total_damage) + scale_colour_gradient(low="red", high="blue")
symbols(damage_bl1$x_coord, damage_bl1$y_coord, circles=damage_bl1$total_damage)
install.packages("spatstat")
library(spatstat)
names(damage)
damage$x<-c(0,21)
damage$y<-c(0-8)
damage$y<-c(0,8)
View(damage)
y<-c(0,8)
x<-c(0,21)
y<-c(0,8)
spat<-ppp(damage_bl1$x_coord, damage_bl1$y_coord, x, y)
plot(split(spat),main="")
plot(spat),main="")
plot(spat, main="")
plot(spat)
x<-c(0,22)
y<-c(0,9)
spat<-ppp(damage_bl1$x_coord, damage_bl1$y_coord, x, y)
plot(spat)
pairdist(spat)
dist_mat<-pairdist(spat)
View(dist_mat)
library(spatstat)
library(spatstat)
library(ggplot2)
setwd("~/Dropbox/Weevils/Analysis")
read.csv(file="damage.csv")
install.packages("spatstat")
install.packages("spatstat")
168^168
View(dist_mat)
#Weevil damage 17/11/15
install.packages("ggplot2")
install.packages("spatstat")
library(spatstat)
library(ggplot2)
setwd("~/Dropbox/Weevils/Analysis")
read.csv(file="damage.csv")
damage<-read.csv(file="damage.csv")
head(damage)
tail(damage)
damage$block<-as.factor(damage$block)
#Plots
plot(total_damage~population, data=damage)
plot(prev_damage~population, data=damage)
plot(curr_damage~population, data=damage)
#Basic ANOVA
pop_total_lm<-lm(total_damage~population, data=damage)
summary.aov(pop_total_lm)
